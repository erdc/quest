stages:
  - run & test
  - deploy
  - toolbox # helpful scripts

# Using YAML anchors to simplify configuration (reuse definitions)
.py2_template: &py2_job
  variables: {MY_PY_VER: py2}

.py3_template: &py3_job
  variables: {MY_PY_VER: py3}

.linux_template: &linux_job
  tags: [linux]

.mac_template: &mac_job
  tags: [mac]

### Run & Test stage jobs

.unix-like_template: &unix-like_job
  stage: run & test
  script:
    - export PATH=$MY_CONDA_PATH:$PATH
    - conda info -a
    - if conda env list | grep -q quest-$MY_PY_VER-$CI_BUILD_REF; then conda env remove -q -y -n quest-$MY_PY_VER-$CI_BUILD_REF; fi
    - conda env create -q -n quest-$MY_PY_VER-$CI_BUILD_REF -f ${MY_PY_VER}_conda_environment.yml
    - source activate quest-$MY_PY_VER-$CI_BUILD_REF
    - python setup.py install
    - py.test test -l --verbose --cov=quest --rpc-port-range $MY_RPC_START_PORT $MY_RPC_END_PORT
    - source deactivate
    - conda env remove -q -y -n quest-$MY_PY_VER-$CI_BUILD_REF

.windows_template: &windows_job
  stage: run & test
  script:
    # GitLab Runner places the following calls in a batch file to run, which can cause change behavior. 
    # Take care in escaping special characters (see http://www.robvanderwoude.com/escapechars.php)
    #   For example a unquoted pipe needs double escaping to pass through 2 layers (interpration
    #   and delayed expansion): ^^^|
    #   Was not able to determine proper escaping for logical && and ||
    - call set PATH=%MY_CONDA_PATH%\..;%MY_CONDA_PATH%;%PATH%
    - call conda info -a
    - if exist %MY_CONDA_PATH%\..\envs\quest-%MY_PY_VER%-%CI_BUILD_REF% rd /s /q %MY_CONDA_PATH%\..\envs\quest-%MY_PY_VER%-%CI_BUILD_REF%
    - call conda env create -q -n quest-%MY_PY_VER%-%CI_BUILD_REF% -f %MY_PY_VER%_conda_environment.yml
    - call activate quest-%MY_PY_VER%-%CI_BUILD_REF%
    - python setup.py install
    - call py.test test -l --verbose --cov=quest
    - call deactivate
    - call conda env remove -q -y -n quest-%MY_PY_VER%-%CI_BUILD_REF%
  tags: [win]

run_and_test_linux_py2:
  <<: [*unix-like_job, *linux_job, *py2_job]

run_and_test_linux_py3:
  <<: [*unix-like_job, *linux_job, *py3_job]
    
run_and_test_mac_py2:
  <<: [*unix-like_job, *mac_job, *py2_job]

run_and_test_mac_py3:
  <<: [*unix-like_job, *mac_job, *py3_job]
    
run_and_test_win_py2:
  <<: [*windows_job, *py2_job]

run_and_test_win_py3:
  <<: [*windows_job, *py3_job]

### Deploy stage jobs

docs:
  stage: deploy
  only:
    - master@computational-analysis-and-mechanics/quest
  script:
    - export PATH=$MY_CONDA_PATH:$PATH
    - conda info -a
    - if conda env list | grep -q quest-$MY_PY_VER-$CI_BUILD_REF; then conda env remove -q -y -n quest-$MY_PY_VER-$CI_BUILD_REF; fi
    - conda env create -q -n quest-$MY_PY_VER-$CI_BUILD_REF -f ${MY_PY_VER}_conda_environment.yml
    - source activate quest-$MY_PY_VER-$CI_BUILD_REF
    - python setup.py install
    - conda install sphinx
    - make -C docs html
    - tar -czf documentation.tar.gz docs/_build/html
    - source deactivate
    - conda env remove -q -y -n quest-$MY_PY_VER-$CI_BUILD_REF
  artifacts:
    paths:
      - documentation.tar.gz
    expire_in: 1 week
  tags:
    - docs

### Toolbox stage jobs

# These are manual jobs to help administer a runner in case triage is necessary and the runner's
# machine admin is unavailable.
#
# From the project's GitLab Runner interface, edit the sick runner's tags list to include the tag
# of the desired toolbox job. Then manually start the desired toolbox job from the project's
# GitLab Pipeline interface. The CI system will assign the job to runner based on the special tag.
# When the job is completed, remove the toolbox job tag from the runner. Only one runner should
# have the toolbox job tag to ensure apropriate assignment.
#
# These jobs may interfere with other currently running jobs from the main project and forks.

# Nuke all existing quest environments (can kill active envs from other running jobs!)
# Toolbox job tag: clean_conda_envs
.cleanup_conda_envs_unix-like_template: &cleanup_conda_envs_unix-like
  stage: toolbox
  script:
    - if $MY_CONDA_PATH/conda env list | grep -q quest-py; then rm -rdf $MY_CONDA_PATH/../envs/quest-py*; fi
  when: manual

cleanup_conda_envs_windows:
  stage: toolbox
  script:
    - for /d %%G in ("%MY_CONDA_PATH%\..\envs\quest-py*") do rd /s /q "%%~G"
  when: manual
  tags: [win, clean_conda_envs]

cleanup_conda_envs_linux:
  <<: *cleanup_conda_envs_unix-like
  tags: [linux, clean_conda_envs]

cleanup_conda_envs_mac:
  <<: *cleanup_conda_envs_unix-like
  tags: [mac, clean_conda_envs]

# Update the conda package manager (can interrupt other running jobs since conda is momentarily unavailable!)
# Toolbox job tag: update_conda_manager
.update_conda_manager_unix-like_template: &update_conda_manager_unix-like
  stage: toolbox
  script:
    - $MY_CONDA_PATH/conda update -q conda
  when: manual

update_conda_manager_windows:
  stage: toolbox
  script:
    - call %MY_CONDA_PATH%\conda update -q conda
  when: manual
  tags: [win, update_conda_manager]

update_conda_manager_linux:
  <<: *update_conda_manager_unix-like
  tags: [linux, update_conda_manager]

update_conda_manager_mac:
  <<: *update_conda_manager_unix-like
  tags: [mac, update_conda_manager]
